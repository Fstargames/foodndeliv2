# Copyright Broadcom, Inc. All Rights Reserved.
# SPDX-License-Identifier: APACHE-2.0

## @section Global parameters
global:
  imageRegistry: ""
  imagePullSecrets: []
  defaultStorageClass: ""
  storageClass: "" # DEPRECATED
  security:
    allowInsecureImages: false
  compatibility:
    openshift:
      adaptSecurityContext: auto

kubeVersion: ""
nameOverride: ""
fullnameOverride: ""
namespaceOverride: "" # If you are deploying to a specific namespace other than 'default', set it here.
commonLabels: {}
enableServiceLinks: true
commonAnnotations: {}
dnsPolicy: ""
dnsConfig: {}
clusterDomain: cluster.local
extraDeploy: []
usePasswordFiles: true # Keep this as true if using existingSecret for passwords

diagnosticMode:
  enabled: false
  command:
    - sleep
  args:
    - infinity

## @section Keycloak parameters
image:
  registry: docker.io
  repository: bitnami/keycloak
  tag: 26.2.4-debian-12-r0 # This matches your previous deployment, good.
  digest: ""
  pullPolicy: IfNotPresent
  pullSecrets: []
  debug: false

auth:
  adminUser: admin # Username for the Keycloak master realm admin
  adminPassword: "" # Leave blank as we are using existingSecret
  existingSecret: "kcsecrets" # Name of the K8s secret you will create
  passwordSecretKey: "admin-password" # Key within the 'kcsecrets' for the admin password
  annotations: {}

customCaExistingSecret: ""

tls:
  enabled: true # Enable TLS
  autoGenerated: true # For now, let Helm/Keycloak generate self-signed certs. We will change this in Task 3c.
  existingSecret: "" # Leave blank when autoGenerated is true
  usePem: false # Not using PEM directly with autoGenerated for now
  truststoreFilename: "keycloak.truststore.jks"
  keystoreFilename: "keycloak.keystore.jks"
  keystorePassword: "" # Auto-generated will handle this
  truststorePassword: "" # Auto-generated will handle this
  passwordsSecret: "" # Not needed with autoGenerated

spi:
  existingSecret: ""
  truststorePassword: ""
  truststoreFilename: "keycloak-spi.truststore.jks"
  passwordsSecret: ""
  hostnameVerificationPolicy: ""

adminRealm: "master"
production: false # Set to true for production later. For dev, false is fine.
                 # If true, TLS is strictly required unless proxy=edge
proxyHeaders: "" # Default is fine for now. Set to "xforward" or similar if behind a specific reverse proxy that sets X-Forwarded-* headers.
proxy: "" # DEPRECATED, use proxyHeaders if needed. "" (none) is fine for direct access or LoadBalancer.
httpRelativePath: "/"

configuration: ""
existingConfigmap: ""
extraStartupArgs: ""
enableDefaultInitContainers: true
initdbScripts: {}
initdbScriptsConfigMap: ""
command: []
args: []
extraEnvVars: []
extraEnvVarsCM: ""
extraEnvVarsSecret: ""

## @section Keycloak statefulset parameters
replicaCount: 1
revisionHistoryLimitCount: 10

containerPorts:
  http: 8080  # Keycloak container listens on 8080 for HTTP
  https: 8443 # Keycloak container listens on 8443 for HTTPS
  metrics: 9000
extraContainerPorts: []
statefulsetAnnotations: {}

podSecurityContext:
  enabled: true
  fsGroupChangePolicy: Always
  sysctls: []
  supplementalGroups: []
  fsGroup: 1001

containerSecurityContext:
  enabled: true
  seLinuxOptions: {}
  runAsUser: 1001
  runAsGroup: 1001
  runAsNonRoot: true
  privileged: false
  readOnlyRootFilesystem: true # Good security practice
  allowPrivilegeEscalation: false
  capabilities:
    drop: ["ALL"]
  seccompProfile:
    type: "RuntimeDefault"

# MODIFICATION: Explicitly define resources instead of using preset to address Helm warning
resourcesPreset: "none" # Disable preset
resources:
  requests:
    memory: "1Gi" # Example, adjust based on your Minikube capacity
    cpu: "500m"   # Example
  limits:
    memory: "2Gi" # Example
    cpu: "1"      # Example

livenessProbe:
  enabled: true
  initialDelaySeconds: 300
  periodSeconds: 10 # Increased slightly from 1 for less aggressive probing initially
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  enabled: true
  initialDelaySeconds: 60 # Increased slightly
  periodSeconds: 10
  timeoutSeconds: 5 # Increased slightly
  failureThreshold: 6 # Increased slightly, give it more time to become ready
  successThreshold: 1

startupProbe: # Consider enabling for complex startups, but default is fine for now
  enabled: false
  initialDelaySeconds: 30
  periodSeconds: 5
  timeoutSeconds: 1
  failureThreshold: 60
  successThreshold: 1

customLivenessProbe: {}
customReadinessProbe: {}
customStartupProbe: {}
lifecycleHooks: {}
automountServiceAccountToken: true # Chart default
hostAliases: []
podLabels: {}
podAnnotations: {}
podAffinityPreset: ""
podAntiAffinityPreset: soft
nodeAffinityPreset:
  type: ""
  key: ""
  values: []
affinity: {}
nodeSelector: {}
tolerations: []
topologySpreadConstraints: []
podManagementPolicy: Parallel
priorityClassName: ""
schedulerName: ""
terminationGracePeriodSeconds: ""
updateStrategy:
  type: RollingUpdate
  rollingUpdate: {}
minReadySeconds: 0
extraVolumes: []
extraVolumeMounts: []
initContainers: []
sidecars: []

## @section Exposure parameters
service:
  type: LoadBalancer # MODIFICATION: Use LoadBalancer for easier external access with Minikube
  http:
    enabled: true
  ports:
    http: 80   # External port for HTTP
    https: 443 # External port for HTTPS
  nodePorts: # These are ignored if type is LoadBalancer and not strictly needed for ClusterIP
    http: ""
    https: ""
  sessionAffinity: None
  sessionAffinityConfig: {}
  clusterIP: ""
  loadBalancerIP: "" # Let Minikube assign
  loadBalancerSourceRanges: []
  externalTrafficPolicy: Cluster
  annotations: {}
  extraPorts: []
  headless:
    annotations: {}
    extraPorts: []

ingress:
  enabled: false # Not using Ingress for now, LoadBalancer is simpler with Minikube tunnel
  # ... (rest of ingress settings can be left as default if not enabled)

adminIngress:
  enabled: false
  # ... (rest of adminIngress settings)

networkPolicy:
  enabled: true # Keep default, good for security
  allowExternal: true
  allowExternalEgress: true
  kubeAPIServerPorts: [443, 6443, 8443]
  extraIngress: []
  extraEgress: []
  ingressNSMatchLabels: {}
  ingressNSPodMatchLabels: {}

serviceAccount:
  create: true
  name: ""
  automountServiceAccountToken: false # Good practice to disable if not strictly needed by the pod itself
  annotations: {}
  extraLabels: {}

rbac:
  create: false # Not creating specific RBAC rules for Keycloak itself via Helm for now
  rules: []

pdb:
  create: true
  minAvailable: ""
  maxUnavailable: 1 # Allow one pod to be unavailable during disruptions if replicaCount > 1

autoscaling:
  enabled: false
  # ... (rest of autoscaling settings)

## @section Metrics parameters
metrics:
  enabled: false # Can enable later if needed for Prometheus scraping directly from Keycloak
  # ... (rest of metrics settings)

## @section keycloak-config-cli parameters
keycloakConfigCli:
  enabled: false # Not using this for now. You'll configure via UI/Admin REST API.
  # ... (rest of keycloakConfigCli settings)

## @section Database parameters
postgresql:
  enabled: true # Use the bundled PostgreSQL for simplicity
  auth:
    postgresPassword: "" # Leave blank if existingSecret is used for this
    username: bn_keycloak # Default Keycloak DB user
    password: ""          # Leave blank, will use existingSecret
    database: bitnami_keycloak # Default Keycloak DB name
    existingSecret: "kcsecrets" # Use the K8s secret for DB passwords
    secretKeys:
      userPasswordKey: "keycloak-password"   # Key in 'kcsecrets' for 'bn_keycloak' user's password
      adminPasswordKey: "postgres-password" # Key in 'kcsecrets' for PostgreSQL 'postgres' admin user password
  architecture: standalone
  # You might want to add persistence for PostgreSQL here for a more robust dev setup
  # primary:
  #   persistence:
  #     enabled: true
  #     size: 8Gi # Or smaller for dev, e.g., 1Gi
  #     storageClass: "" # Or your Minikube's default SC

externalDatabase:
  # These are ignored since postgresql.enabled is true
  host: ""
  port: 5432
  user: bn_keycloak
  database: bitnami_keycloak
  password: ""
  existingSecret: ""
  existingSecretHostKey: ""
  existingSecretPortKey: ""
  existingSecretUserKey: ""
  existingSecretDatabaseKey: ""
  existingSecretPasswordKey: ""
  annotations: {}

## @section Keycloak Cache parameters
cache:
  enabled: true # Keep default for now. 'local' cache is only for replicaCount=1 if you disable this.
  stack: kubernetes
  configFile: "cache-ispn.xml"
  useHeadlessServiceWithAppVersion: false

## @section Keycloak Logging parameters
logging:
  output: default
  level: INFO